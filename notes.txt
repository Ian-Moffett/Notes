Template: https://github.com/Ian-Moffett/UEFITemplate2


Create an array of uint8_t which will be our stack.
We will allocate it in BSS.
(I like to make it 8KB).

"stivale2 offers a runtime terminal service which can be ditched at any
time, but it provides an easy way to print out to graphical terminal,
especially during early boot.
Read the notes about the requirements for using this feature below this
code block."

To enable it do:

static struct stivale2_header_tag_terminal terminal_hdr_tag = {
    .tag = {
        .identifier = STIVALE2_HEADER_TAG_TERMINAL_ID,
        // End of linked list tags.
        .next = 0
    }, 
    
    .flags = 0
}


We want to define a tag that tells the bootloader
we want to use a framebuffer


static struct stivale2_header_tag_framebuffer lfb_tag = {
    .tag = {
        .identifier = STIVALE2_HEADER_TAG_FRAMEBUFFER_ID,
        .next = (uint64_t)&terminal_hdr_tag 
    },

    // Leave zero so the bootloader picks.
    .framebuffer_width = 0,
    .framebuffer_height = 0,
    .framebuffer_bpp = 0,
};


"The stivale2 specification says we need to define a "header structure".
This structure needs to reside in the .stivale2hdr ELF section in order
for the bootloader to find it. We use this __attribute__ directive to
tell the compiler to put the following structure in said section."

__attribute__((section(".stivale2hdr"), used)) static struct stivale2_header stivale_hdr = {
    // Alternate entry point which we will not use so zero.
    .entry_point = 0,
    // Remember, stack grows downwards so we add sizeof(stack).
    .stack = (uintptr_t)<your stack you defined at the top> + sizeof(stack),
    .flags = (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4),
    // This is the root node of the linked list and should point to the first node.
    .tags = (uintptr_t)&lfb_tag
};


We need to write a helper function that helps us find tags that we
want from the bootloader.

void* get_tag(struct stivale2_struct* stivale2_struct, uint64_t id) {
    struct stivale2_tag* current_tag = (void*)stivale2_struct->tags;
    while (1) {
        // If the tag pointer is NULL (end of linked list), we did not find
        // the tag. Return NULL to signal this.
        if (current_tag == NULL) {
            return NULL;
        }
 
        // Check whether the identifier matches. If it does, return a pointer
        // to the matching tag.
        if (current_tag->identifier == id) {
            return current_tag;
        }
 
        // Get a pointer to the next tag in the linked list and repeat.
        current_tag = (void*)current_tag->next;
    }
}

// Kernel entry.
void _start(struct stivale2_struct* stivale2_struct) {
    // Fetch terminal tag.
    struct stivale2_struct_tag_terminal* term_str_tag;
    term_str_tag = get_tag(stivale2_struct, STIVALE2_STRUCT_TAG_TERMINAL_ID);

    // If not tag found, hang.
    if (!(term_str_tag)) {
        while (1) {
            __asm__ _volatile__("hlt");
        }
    }

    Fetch address of terminal write function.
    void* term_write_addr = (void*)term_str_tag->term_write;
    
    Assign address to function pointer.
    void(*kwrite)(const char* str, size_t length) = term_write_addr;
    kwrite("Hello!", 6);

    while (1) {
        __asm__ __volatile__("hlt");
    }

}
